# Spec Traceability Matrix

How to jump from a spec principle to the exact code and evidence that proves it works.

| Requirement | Code modules | Automated coverage | Manual drills / gaps |
| --- | --- | --- | --- |
| Complete isolation | `src/core/workspaces.ts` (per-task git clones + branch prep), `src/docker/manager.ts` + `src/docker/docker.ts` (container creation, log streaming, cleanup) | `src/core/workspaces.test.ts` (clones, branch reuse, rejects mismatched repos), `src/docker/manager.test.ts` (streams logs, removes containers), `src/__tests__/docker-e2e.test.ts` (Docker workers run per task with container start/exit events) | None — Docker E2E covers the isolation path. |
| Safe parallelism | `src/core/scheduler.ts` (lock-aware batching), `src/core/manifest-compliance.ts` + `src/core/manifest-rescope.ts` (enforce + auto-add missing locks/files) | `src/core/scheduler.test.ts` (read/read allowed, read/write blocked, deterministic batches), `src/core/manifest-compliance.test.ts` (blocks undeclared writes), `src/core/manifest-rescope.test.ts` (adds missing locks/files or fails loudly) | No manual drill required; add one if we hit lock starvation in production. |
| Total resumability | `src/core/state.ts` + `src/core/state-store.ts` (persisted run state, recovery), `worker/state.ts` (attempts + checkpoints), `src/core/executor.ts` (resume/reattach paths), `src/core/graceful-stop.ts` (signal-aware stop) | `src/core/state.test.ts` (resets running tasks to pending, persists state atomically), `worker/state.test.ts` (records thread ids + checkpoints), `src/core/graceful-stop.test.ts` (SIGINT logs `run.stop` and allows resume), `src/__tests__/resume-drill.test.ts` (Docker acceptance: crash orchestrator, `resume` reattaches and completes) | `docs/ops/resume-drill.md` — expect `container.reattach` in `orchestrator.jsonl`, `codex.thread.resumed` in task `events.jsonl`, and run state `status: "complete"`. |
| Structured logging | `src/core/logger.ts` (JSONL writer), `src/core/log-index.ts` (SQLite index), `src/core/log-query.ts` (search/filter), `src/cli/logs.ts` (timeline/failures views) | `src/core/logger.test.ts` (run/task metadata in JSONL), `src/core/log-index.test.ts` (ingest + query across orchestrator/task/validator logs), `src/core/log-query.test.ts` (search + task scoping), `src/cli/logs.test.ts` (timeline + failure grouping) | Optional spot-check: `npm run dev -- logs timeline --use-index` after runs if new event types are added. |
| Validation gating | `src/validators/test-validator.ts` + `src/validators/doctor-validator.ts` (LLM validators), `src/core/executor.ts` (invokes validators, routes block/warn), `src/core/manifest-compliance.ts` + `src/core/manifest-rescope.ts` (policy enforcement), `src/core/budgets.ts` (token/cost gates) | `src/validators/test-validator.test.ts` (captures changed tests, writes reports), `src/validators/doctor-validator.test.ts` (summarizes doctor runs + canary), `src/core/manifest-compliance.test.ts` and `src/core/manifest-rescope.test.ts` (policy + auto-rescope), `src/core/budgets.test.ts` (warn/block breaches) | None — validators and policy tests cover the gating logic; add a drill if a new validator type ships. |
| Planning → tasks → execution pipeline | `src/core/autopilot.ts` (interviews + artifacts), `src/core/task-writer.ts` (normalized manifests/specs), `src/cli/plan.ts` (planner CLI), `src/core/executor.ts` (plan batching, worker orchestration), `src/core/config-loader.ts` (config validation) | `src/core/autopilot.test.ts` (LLM interview flow + artifact writing), `src/core/task-writer.test.ts` (deduped locks/files, plan index), `src/__tests__/config-loader.test.ts` + `src/__tests__/task-loader.test.ts` (config + manifest validation), `src/__tests__/integration-run.test.ts` (mock planner → run merges tasks), `src/__tests__/docker-e2e.test.ts` (planner + Docker workers end-to-end) | `docs/ops/pilot-run.md` captures a manual autopilot-to-run pass; expect tasks merged on `main` and release notes/feature files updated. |
